---
本文档包含：
1. 作业及成绩评定说明
2. 公测部分规则说明
3. bug修复规则说明
---

# 作业及成绩评定说明

## 分数计算说明

### 总分

总分 = 作业分 + 奖励分

> 奖励分：主要来自讨论区的贡献

### 作业分

编程作业分 = 公测分 + 代码风格分

非编程作业分 = 评价分

> 非编程作业分：博客作业等

### 公测分

公测分 = 中测基础分 + 中测过程分 + 强测结果分

> 注：在要求使用 Junit 的作业中，中测基础分包含一定比例的 Junit 得分。
>
> 注：总分不等于最后该课程的总成绩，我们会根据最终得分情况进行调整，进行一定的折算。
>
> 注：要求代码风格分不能低于一定下限，否则会根据代码风格检测结果进行惩罚，最高可能仅得到当前已得分数的 60%
>
> 注：各项分数所占比例目前不予公布

# 公测部分规则说明

## 一、测试内容及难度梯度

## 中测

- 中测包括两部分样例，基础样例和进阶样例。

  基础样例：难度极低，仅测试最基本的功能，不设任何坑点。

  进阶样例：难度中等，每组测试样例有单一的、小的坑点，旨在给同学们提供构造测试样例的思路。

- 中测的将会规定一个**比较充分的测试次数**，**在规定次数内AC则不扣分，否则将依规扣分**，中测的分数计算详见公测分数计算规则。

- 中测**实时公布测试结果，且公布一定的测试数据信息，便于同学们debug，具体公布内容由课程组根据情况进行调整**。

## 强测

- 数据量较大，有较为复杂的坑点，以及边界测试、压力测试等，**作为公测得分的主要评判依据**。
- 强测将**拉取最后一次中测提交程序进行测试**，也就是说测试次数为1次。
- 强测**不会实时公布测试结果，会在bug修复阶段开始时公布测试结果和所有测试样例具体信息**。

## 二、有关测试数据的公开

- 中测：**公开部分数据**，但实际测试数据组数要多于公开的组数，在指导书发布两天后公开，即周日中午12：00中测窗口开启后，部分样例在评测错误后会返回必要的信息(stdin, stdout, stderr)，这样做一方面避免了同学通过数据来发现bug，而不是自己构造数据；另一方面也可以及时地为进度较快的同学提供测试。
- 强测：**延迟公开测试数据**。在中测提交截止后由系统拉取最后一次中测提交程序进行自动化测试。在强测结束后，bug修复阶段开始时公布测试结果和测试样例具体信息。

## 三、公测分数计算规则（百分制）

​	**公测分 = 中测基础分+ 中测过程分 + 强测结果分**

- **中测基础分**：此次作业为有效作业即可获得中测基础分，即通过所有中测基础样例。

- **中测过程分 = - max(0, 提交总次数 - 规定次数) * (100 / 规定次数)** 

  中测提交次数有上限，即最大提交次数，其值为规定次数 * 2，用完最大提交次数之后，将无法再提交。

- **强测结果分**：
  $$强测结果分=\frac{\sum_{正确样例}w_i}{\sum_{总样例}w_i} \times 100，\quad其中w_i是第i个样例对应的分值$$

# bug修复规则说明

## 一、bug修复整体安排

#### 目的

bug 修复是提升软件质量的一个重要手段。本课程 bug 修复阶段目的在于让同学们修正之前作业中的错误，为后续系列作业建立良好的基础。

修正了的 bug 可获得一定的奖励得分。

#### 时间

没有特殊公告时，每周五下午12:00可以开始进行 bug 修复工作，每次作业的 bug 修复阶段截止到下一次作业的bug修复开始时间节点。

#### 公开样例

此阶段开始时，每位同学将看到测出自己程序 bug 的样例（含输入和期望输出）。这些样例包括公测阶段未通过的样例。

## 二、修复代码的提交细则

#### bug 修复尝试

**一次 bug 修复尝试**需要提交的内容包括：修复 bug 后的代码 + 对应修复的测出 bug 的测试样例 + 对应说明文档（可选）

- **修复 bug 后的代码**提交方式同作业提交方式（通过 git 提交，在课程网站选择版本评测），且与上一版评测代码相比，需满足代码修改量要求
- **对应修复的测出 bug 的测试样例**根据对修复代码的评测结果生成，评测的数据点包含所有强测数据点

#### 有效修复

对于一次 bug 修复尝试，我们会使用所有强测样例，对提交的代码进行测试，只有**通过原本未通过的部分或全部测试用例，并且不产生新的 bug** 才能视为有效修复，否则就是无效修复。（产生新 bug：原本通过的测试用例在修复后无法通过，即需要通过回归测试）。

如果存在多个 bug，并且想要分别合并修复，则请采用分批修复的方式，即每次提交修复一个 bug，多次提交。

修复代码的提交**没有次数限制**，但是提交的修复被认定无效之后 30 分钟内无法再提交修复。

#### 代码修改量要求

以强测代码为初始版本，每有效修复一次更新一次版本，则要求该次修复和上次修复的代码变动**小于等于 5 行**。如果变动不符合该要求，但确实认为本次修复是针对于一个 bug 的，需要额外提交文档，阐述自己所修复的这一处 bug，提交状态为待审核，之后由助教进行审核，如果通过，视为满足代码修改量要求，假若不通过，视为不满足，学生**没有机会申诉**。助教将尽可能及时审核同学们的申请，审核压力大时，**保证最长 72h 内解决**。

注：该行数限制必须满足代码风格规范要求，比如一行不能超过 80 个字符。此外，5行的限制是一个暂定数值，课程组会根据情况适当进行调整。

#### **合并修复和非合并修复**

有效修复且满足代码修改量要求的修复，是合并修复，否则是非合并修复。对于合并修复，其对应的样例视为 shared（同质）bug，按照 shared bug 的方式进行奖励和惩罚。对于非合并修复，则还是一个样例算一个 bug，按照 solid bug 的方式进行计算。

#### 提交文档要求

文档包括但不限于修复 bug 所对应的代码前后改动，bug 原因简述。实际操作中在课程系统网站对应的文本框填入相关内容即可。文档的目的在于使助教认同不符**代码修改量要求**的代码修复确实仅修复了 1 处 bug。

#### bug 修复作弊

假若检查出学生使用作弊手段进行 bug 修复，包括但不限于下列情况的，本次作业认定为**无效作业**。

- 打表型修复，例如用 `if... else...` 语句进行特判输出期望结果。

注：所有的作弊情况都会经过自动化检测和多名助教复核，如果自动化检查和多名助教都认为存在作弊行为，才会视为作弊。

## 三、bug修复阶段补充条例

#### 关于 bug 修复和 checkstyle

在 bug 修复阶段，仍然首先会进行 checkstyle 代码风格测试，我们将会记录强测所用代码（即中测最后一次提交）的 checkstyle 分数作为初始基准分，任何 bug 修复提交，如果低于这个基准分，将会被系统拒绝该次修复。而且，在多次修复行为中，必须保证 checkstyle 分数是单调递增（大于等于）的，即如果本次提交高于上次的 checkstyle 分数，则会更新该基准分。

#### 回归测试样例

回归测试样例包括：所有强测样例

## 四、bug惩罚分最终评定

1. 算法：
   $$
   bug惩罚分=未被修复的bug数\times\alpha+非合并修复对应的bug数+合并修复次数,\quad其中\alpha=2
   $$

2. 未被修复的 bug 数 = 未被有效 bug 修复覆盖的出现 bug 的强测样例数。

3. 依据本算法，一次被合并修复的所有样例认定为一个 shared（同质）bug。

